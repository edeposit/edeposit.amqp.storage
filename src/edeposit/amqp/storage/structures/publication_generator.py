#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# Interpreter version: python 2.7
#
# Imports =====================================================================
from string import Template


# Variables ===================================================================
CLASS_NAME = "Publication"

COMMON_FIELDS = [
    ["title", "(str): Title of the publication."],
    ["author", "(str): Name of the author."],
    ["pub_year", "(str): Year when the publication was released."],
    ["isbn", "(str): ISBN for the publication."],
    ["urnnbn", "(str): URN:NBN for the publication."],
    ["uuid", "(str): UUID string to pair the publication with edeposit."],
    ["aleph_id", "(str): ID used in aleph."],
    ["producent_id", "(str): ID used for producent."],
    ["is_public", "(bool): Is the file public?"],
    ["filename", "(str): Original filename."]
]

COMMUNICATION_FIELDS = [
    ["b64_data", "(str): Base64 encoded data ebook file."],
    ["url", "(str): URL in case that publication is public."],
]

DATABASE_FIELDS = [
    ["file_pointer", "(str): Pointer to the file on the file server."],
]

TEMPLATE = """#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# Interpreter version: python 2.7
#
# !!! DO NOT EDIT THIS FILE - THIS IS GENERATED FILE !!!
# Imports =====================================================================
$imports


# Functions and classes =======================================================

# !!! DO NOT EDIT THIS FILE - THIS IS GENERATED FILE !!!
# !!! DO NOT EDIT THIS FILE - THIS IS GENERATED FILE !!!
$classes
# !!! DO NOT EDIT THIS FILE - THIS IS GENERATED FILE !!!
# !!! DO NOT EDIT THIS FILE - THIS IS GENERATED FILE !!!
"""

COMMUNICATION_STRUCTURE = """
_PUB_FIELDS = [
    $fields
]


class $class_name(namedtuple('$class_name', _PUB_FIELDS)):
    '''
    Communication structure used to sent data to `storage` subsystem over AMQP.

    Attributes:
        $docstring_fields
    '''
    def __new__(self, *args, **kwargs):
        for field, arg in zip(_PUB_FIELDS, args):
            kwargs[field] = arg

        for key in _PUB_FIELDS:
            if key not in kwargs:
                kwargs[key] = None

        return super($class_name, self).__new__(self, **kwargs)

    def __init__(self, *args, **kwargs):
        for field, arg in zip(_PUB_FIELDS, args):
            kwargs[field] = arg

        for key, val in kwargs.iteritems():
            if key not in _PUB_FIELDS:
                raise ValueError("Unknown parameter '%s'!" % key)

            self.__dict__[key] = val
"""

DATABASE_IMPORTS = """
import os
import uuid
import base64

from kwargs_obj import KwargsObj
from persistent import Persistent

from ..settings import PUBLIC_DIR
from ..settings import PRIVATE_DIR

from publication import Publication

""".strip()


DATABASE_STRUCTURE = """
class DB$class_name(Persistent, KwargsObj):
    '''
    Database structure used to store basic metadata about Publications.

    Attributes:
        $docstring_fields
    '''
    def __init__(self, **kwargs):
        $fields
        self._kwargs_to_attributes(kwargs)

    @staticmethod
    def _save_to_unique_filename(pub):
        dirpath = PUBLIC_DIR if pub.is_public else PRIVATE_DIR

        if not os.path.exists(dirpath):
            raise IOError("`%s` doesn't exists!" % dirpath)

        # get uniq filename
        filename = "/"
        while os.path.exists(filename):
            filename = os.path.join(dirpath, str(uuid.uuid4()))

        with open(filename, "wb") as f:
            f.write(
                base64.b64decode(pub.b64_data)
            )

        return filename

    @staticmethod
    def from_comm(pub):
        '''
        Convert communication namedtuple to this class.

        Args:
            pub (obj): :class:`.$class_name` instance which will be converted.

        Returns:
            obj: :class:`DB$class_name` instance.
        '''
        filename = None
        if pub.b64_data:
            filename = DB$class_name._save_to_unique_filename(pub)

        return DB$class_name(
            $comm_to_db_fields
            file_pointer=filename
        )

    def to_comm(self):
        '''
        Convert `self` to :class:`.$class_name`.

        Returns:
            obj: :class:`.$class_name` instance.
        '''
        with open(self.file_pointer) as f:
            data = base64.b64encode(f.read())

        return $class_name(
            $db_to_comm_fields
            b64_data=data
        )

    def __eq__(self, obj):
        if not isinstance(obj, self.__class__):
            return False

        return (
            $eq_fields
        )

    def __ne__(self, obj):
        return not self.__eq__(obj)

    def __hash__(self):
        return hash(
            "".join(x.__repr__() for x in self.__dict__.values())
        )
"""


# Functions & classes =========================================================
def _get_docstring_fields(fields):
    return "\n        ".join(
        name + " " + description
        for name, description in fields
    )


def generate_communication():
    fields = "\n    ".join(
        '"%s",' % name
        for name, x in COMMON_FIELDS + COMMUNICATION_FIELDS
    )

    return Template(COMMUNICATION_STRUCTURE).substitute(
        fields=fields,
        class_name=CLASS_NAME,
        docstring_fields=_get_docstring_fields(
            COMMON_FIELDS + COMMUNICATION_FIELDS
        )
    )


def generate_database():
    fields = "        ".join(
        "self.%s = None\n" % name
        for name, x in COMMON_FIELDS + DATABASE_FIELDS
    )

    spacer3 = 3 * "    "
    comm_to_db_fields = spacer3.join(
        "%s=pub.%s,\n" % (name, name)
        for name, x in COMMON_FIELDS
    )

    db_to_comm_fields = spacer3.join(
        "%s=self.%s,\n" % (name, name)
        for name, x in COMMON_FIELDS
    )

    eq_fields = (" and\n" + spacer3).join(
        "self.%s == obj.%s" % (name, name)
        for name, x in COMMON_FIELDS
    )

    return Template(DATABASE_STRUCTURE).substitute(
        fields=fields,
        class_name=CLASS_NAME,
        comm_to_db_fields=comm_to_db_fields,
        db_to_comm_fields=db_to_comm_fields,
        eq_fields=eq_fields,
        docstring_fields=_get_docstring_fields(
            COMMON_FIELDS + DATABASE_FIELDS
        )
    )


def generate_structures():
    with open("publication.py", "w") as f:
        f.write(
            Template(TEMPLATE).substitute(
                imports="from collections import namedtuple",
                classes=generate_communication()
            )
        )

    with open("db_publication.py", "w") as f:
        f.write(
            Template(TEMPLATE).substitute(
                imports=DATABASE_IMPORTS,
                classes=generate_database()
            )
        )


# Main program ================================================================
if __name__ == '__main__':
    generate_structures()
